\input{../preamble.tex}

\lecturenumber{1}
\title{File\\Systems}
\version{1.0.0}
 
\begin{document}

\begin{frame}[plain, noframenumbering]
    \titlepage
\end{frame}

\begin{slide}
	
	\slidetitle{Inter-computer communication}
	
	Without shared memory, computers need a network to communicate.
	\bigskip
	
	\includegraphics[width=80mm]{inter-computer-comm.png}
	
\end{slide}

\begin{slide}

	\slidetitle{Modes of connection: two design approaches}
	
	Circuit switching (virtual circuit)
	\begin{itemize}
		\item Dedicated path (route) established at setup
		\item Guaranteed (fixed) bandwidth - routers commit to resources
		\item Typically fixed-length packets (cells), each cell only need a virtual circuit ID
		\item Constant latency
	\end{itemize}
	\bigskip
	
	Packet switching (datagram)
	\begin{itemize}
		\item Shared connection; competition for use with others
		\item Data is broken into chunks called packets
		\item Each packet contains a desitnation address
		\item Available bandwidth is up to channel capacity (often smaller)
		\item Variable latency
	\end{itemize}

\end{slide}

\begin{slide}

	\slidetitle{Network protocol layering}
	
	Most popular model of guiding (not specifying) ptotocol layrs is the OSI reference model.
	\medskip
	
	\begin{minipage}{0.3\textwidth}
	\includegraphics[width=35mm]{OSI-model.png}
	\end{minipage}
	\hfill
	\begin{minipage}{0.68\textwidth}
		7. Application: HTTP, email, FTP
		\medskip
		\smallskip
		
		6. Presentation: XDR, MIME, JSON, XML
		\medskip
		\smallskip
		
		5. Session: HTTP 1.1, SSL
		\medskip
		\smallskip
		
		4. Transport: TCP, UDP
		\medskip
		\smallskip
		
		3. Network: IP, X.25
		\medskip
		\smallskip
		
		2. Data Link: Ethernet MAC, PPP
		\medskip
		\smallskip
		
		1. Physical: USB, Bluetooth, Wi-Fi radios
	\end{minipage}

\end{slide}

\begin{slide}

	\slidetitle{Protocol Encapsulation}
	
	At any layer:
	\begin{itemize}
		\item The higher-level protocol headers are just treated like data
		\item Lower-level protocol headers can be ignored
	\end{itemize}
	
	\includegraphics[width=100mm]{protocol-encapsulation.png}
	
\end{slide}

\begin{slide}

	\slidetitle{IP Addressing}
	
	Each network endpoint has a unique IP address
	\begin{itemize}
		\item No relation to an ethernet address
		\item IPv4: 32-bit address
			\begin{itemize}
				\item uoa.auckland.ac.nz = 130.216.5.170
			\end{itemize}
		\item IPv6: 128-bit address
			\begin{itemize}
				\item www.google.com = 2404:6800:4006:804::2004
			\end{itemize}
	\end{itemize}
	\bigskip
	
	Data is broken into packets. Each packet contains
	\begin{itemize}
		\item source and destination IP addresses
		\item Header checksum
		\item Data
	\end{itemize}

\end{slide}

\begin{slide}

	\slidetitle{Communication over IP}
	
	\includegraphics[width=100mm]{comm-over-ip.png}
	\bigskip
	
	TCP: Reliable, in-order byte stream
	\bigskip
	
	UDP: Unreliable, message stream (order not guarantedd)
	
\end{slide}

\begin{slide}

	\slidetitle{Transport Layer}
	
	We want to communicate between applications
	\bigskip
	
	The transport layger gives us logical "channels" for communication
	\begin{itemize}
		\item Processes can write to and receive from these channels.
	\end{itemize}
	\bigskip
	
	Two transport layer protocols in IP are TCP and UDP
	\begin{itemize}
		\item A port number identifies a unique channel on each computer
	\end{itemize}

\end{slide}

\begin{slide}

    \slidetitle{UDP}
	
	All traffic goes to a socket that reads from a host address and port.
	\bigskip
	
	\includegraphics[width=110mm]{udp.png}
	\bigskip
	
	A server creates a socket to receive messages on a specific port number. 
	\bigskip
	
	Packets sent from different processes and/or systems all arrive on the same socket on the server.
	
\end{slide}

\begin{slide}

    \slidetitle{TCP}

	Unique channels identified by
	\begin{itemize}
		\item {Remote host, Remote port, Local host, Local port}
		\item One socket for listening for new connections on a local host, port
		\item Separate communication socket for each "connection"
	\end{itemize}
	\bigskip
	
    \includegraphics[width=100mm]{tcp.png}
	\bigskip
	
	A server creates a socket to listen for connections on a specific port number.
	\bigskip
	
	Each connection results in a new socket at the server.

\end{slide}

\begin{slide}

	\slidetitle{UDP or TCP?}
	
	\begin{itemize}
		\item Web Browsing
		\item Online Gaming
		\item File Transfer
		\item Zoom
		\item Video Streaming
		\item Music Streaming
	\end{itemize}
	
\end{slide}

\begin{slide}

	\slidetitle{Protocols}
	
	Set of rules (\& customs) for communicating
	\bigskip
	
	Exist at different levels:
	\begin{itemize}
		\item Exist at each layer of the network stack
		\item Meaning of bytes
		\item Sequence of request \& response messages
	\end{itemize}

\end{slide}

\begin{slide}

	\slidetitle{Software interaction model}
	
	Socket API: all we get from the OS to access the network
	\bigskip
	
	Socket = distinct end-to-end communication channels
	\bigskip
	
	Line-oriented, text-based protocols common
	\begin{itemize}
		\item Not efficient but easy to debug and use
	\end{itemize}

\end{slide}

\begin{slide}

	\slidetitle{Problems with the socket APIs}
	
	The sockets interface forces a read/write mechanism
	\bigskip
	
	\includegraphics[width=100mm]{socket-api-problem.png}
	\bigskip
	
	Programming is often easier with a functional interface
	\bigskip
	
	To make distributed computing look more like centralized computing, I/O (read/write) is not the way to go.
	
\end{slide}
    
\begin{slide}

    \slidetitle{Remote service - stateful}

    Server knows:
    \begin{itemize}
        \item who has the file open
        \item for what type of access
        \item and where it is in the file etc.
        \item When the client calls open, it receives an identifier to be used to access the file.
        \item Looks very similar to traditional local file access to the client process.
        \item Efficient, the needed data may be read ahead by the server.
        \item Information about the file is held in memory.
        \item If the server crashes
        \begin{itemize}
            \item it is difficult to start again since all the state information is lost.
        \end{itemize}
        \item Server has problems with processes which die
        \begin{itemize}
            \item needs to occasionally check.
        \end{itemize}
    \end{itemize}

\end{slide}

\begin{slide}

    \slidetitle{Remote service - stateless}

    Server does not maintain information on the state of the system. It merely responds to requests.
    \bigskip

    Open and close calls don’t send messages to the server. Handled locally. (Except for access privileges.)
    \bigskip

    Requesting processor has topass all the extra information with each read/write
    \begin{itemize}
        \item e.g., the current file location the process is reading from, accesibility
    \end{itemize}
    \bigskip

    Server doesn't have to worry about processes stopping
    \bigskip

    No complicated recovery process if the server goes down
    
\end{slide}

\begin{slide}

    \slidetitle{Remote Procedue Calls (RPC)}

    RPC abstract attempts to make remote procedure calls look like local ones.

\end{slide}

\begin{slide}

    \slidetitle{Sending a remote call}

    \inputminted[fontsize=\scriptsize]{c}{wmsg.c}

\end{slide}

\begin{slide}

	\slidetitle{Implementing RPC}
	
	No architectural support for remote procedure calls.
	\bigskip
	
	Simulate it with tools we have (local procedure calls)
	\bigskip
	
	\includegraphics[width=120mm]{implement-rpc.png}

\end{slide}

\begin{slide}

    \slidetitle{Implementing RPC}

    Create stub functions:
	\begin{itemize}
		\item to make it appear to the user that the call is local
	\end{itemize}
	\bigskip
	
	On the clinet:
	\begin{itemize}
		\item The stub function (proxy) has the function’s interface
		\item Packages parameters and calls the server
	\end{itemize}
	\bigskip
	
	On the server:
	\begin{itemize}
		\item The stub function (skeleton) receives the request and calls the local function
	\end{itemize}

\end{slide}

\begin{slide}

	\slidetitle{Interface Definition Language (IDL)}
	
	Allow programmer to specify remote procedure interfaces
	\begin{itemize}
		\item (names, parameters, return values)
	\end{itemize}

	An IDL looks similar to function prototypes.
	
\end{slide}

\begin{slide}

    \slidetitle{Interface definition language (IDL) of an adder}

    \inputminted{python}{Adder.idl}

\end{slide}

\begin{slide}

    \slidetitle{Server and client code with RPC}

    \inputminted{python}{server.py}
    \bigskip

    \inputminted{python}{client.py}

\end{slide}

\begin{slide}

    \slidetitle{Stub generator}
    
    \textbf{Marshalling/Unmarshalling}: Converting data structures into byte streams for transmission (marshalling) and reconstructing them on the receiving end (unmarshalling).
    \bigskip

    \textbf{Buffering}: Temporarily storing data in memory to optimize transmission.
    \bigskip

    \textbf{Message Transmission}: Sending and receiving messages over the network.
    \bigskip

    Server and client code can focus solely on implementing the core application logic.

\end{slide}

\begin{slide}

	\slidetitle{RPC Benefits}

	RPC gives us a procedure call interface
	\bigskip
	
	Writing applications is simplified
	\begin{itemize}
		\item RPC hides all network code into stub functions
		\item Application programmers don't have to worry about details
		\begin{itemize}
			\item Sockets, port numbers, byte ordering
		\end{itemize}
	\end{itemize}
	
\end{slide}

\end{document}
